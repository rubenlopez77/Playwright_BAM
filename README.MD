# ğŸ§ª Behavior Annotation Model (BAM!) 


> ### âš ï¸ Aviso importante â€” Community Edition (PoC)
> Esta ediciÃ³n es una **Proof of Concept (PoC)** diseÃ±ada para explorar arquitecturas QA alineadas con **ISTQB**, **IEEE 29119** e **ISO/IEC 25010**.
> Su objetivo es acadÃ©mico y de arquitectura: demostrar la viabilidad de un **Single Source of Truth** en QA.

![BAM Community Edition](https://img.shields.io/badge/BAM_Community_Edition-v0.1.5-blueviolet?logo=testcafe&logoColor=white&style=flat-square)

---

> *"La funciÃ³n del QA ya no es 'ver si funciona', sino orquestar la calidad desde la intenciÃ³n del negocio hasta la evidencia tÃ©cnica."*

---

## ğŸ¯ PropÃ³sito: Â¿Por quÃ© BAM?

Los frameworks de automatizaciÃ³n tradicionales comparten tres problemas estructurales:

âŒ Fragilidad: 

Los tests dependen de selectores, lÃ³gica repetida y flujos inconsistentes. Tests imperativos, alto acoplamiento y alta deuda.

âŒ Silos de evidencia: 

Playwright genera su reporte, Cucumber otro, k6 otroâ€¦ sin un estÃ¡ndar comÃºn.

âŒ Ausencia de trazabilidad real

No se sabe:
- QuÃ© requisito cubre cada test
- QuÃ© AC se ha validado
- QuÃ© dato se ha usado
- QuÃ© componente ha fallado ni por quÃ©

âŒ DesconexiÃ³n entre negocio y QA

> Los steps suelen describir cÃ³mo se hace algo, no quÃ© se valida.

## ğŸŸ£ Un Single Source of Truth para gobernarlos a todos.

Un ecosistema unificado en el que todas las pruebas â€”funcionales, API y rendimientoâ€” comparten un metamodelo comÃºn de evidencia.
Ese metamodelo es el BMS (Behavioral Metadata Standard).

>BAM no ejecuta pruebas: gobierna calidad.

## ğŸ›ï¸ 2. Arquitectura en 3 capas (alineada con ISTQB)

BAM organiza todo el sistema de pruebas en tres capas bien definidas:

#### 2.1 Capa de IntenciÃ³n (Business / BDD)
-  Escenarios escritos en Gherkin puro.
-  Metadata BMS vÃ­a tags (@ID, @Module, @Risk, @AC1, @Dataâ€¦).
-  Lenguaje entendible por negocio, QA y desarrollo.

> AquÃ­ se define quÃ© comportamiento queremos validar.

#### 2.2 Capa de Componentes (Design / AbstracciÃ³n TÃ©cnica)

La Capa de Componentes es el corazÃ³n del diseÃ±o:

- Componentes atÃ³micos: encapsulan selectores e interacciones.
- Pages declarativas: solo declaran quÃ© componentes contienen.
- Helpers: orquestan flujos reutilizables (login, navegaciÃ³n, etc.).

> AquÃ­ se define cÃ³mo interactuamos con el sistema, sin contaminar los tests.


#### 2.3 Capa de EjecuciÃ³n (Runner / OrquestaciÃ³n)

BAM orquesta diferentes motores bajo un mismo estÃ¡ndar:

ğŸ–¥ï¸ UI: Playwright 

ğŸ”Œ API: Axios / Playwright API

ğŸš€ Performance: k6

> Independientemente del motor (se podrÃ­a usar Selenium, Cypress, Appium, JMeter, Supertest.. ), el resultado se normaliza en un **BMS JSON comÃºn**.

## ğŸŸ¦ 3. Modelo de Componentes â€” Eliminando fragilidad estructural

El Component Model garantiza que toda interacciÃ³n tÃ©cnica estÃ¡ centralizada.

###  3.1 Componentes AtÃ³micos

Cada interacciÃ³n UI/API se encapsula en un componente o clase:

-  click, fill, waitFor, modal, alert, llamadas APIâ€¦

Ventajas:

-  Un selector â†’ un Ãºnico lugar.

-  ReutilizaciÃ³n masiva.

-  Cambios en la UI afectan al mÃ­nimo cÃ³digo posible.

-  Control de errores mÃ¡s preciso (componente, acciÃ³n, selector).

###  3.2 Pages Declarativas
Una Page solo declara quÃ© componentes contiene y cÃ³mo se combinan. Sin lÃ³gica â€œde negocioâ€.

```typescript
// Ejemplo de Page Object Declarativo en BAM
  async loginWith(set: CredentialSet) {
    await this.loginButton.click();
    await this.modal.waitVisible();
    await this.username.fill(set.username);
    await this.password.fill(set.password);
    await this.submitButton.click();
  }
```
>Esto reduce la deuda tÃ©cnica y simplifica radicalmente la experiencia de desarrollo (DX).

### 3.3 Steps declarativos â†’ IntenciÃ³n funcional
El Step representa intenciÃ³n funcional, no detalles tÃ©cnicos.
```typescript
// Test declarativos. PrÃ¡cticamente Gherkin
When('the user logs in with invalid credentials', async function () {
  const user = this.getPage(LoginPage);
  await user.loginWith(credentials.invalid);
});
```

âœ” Onboarding rÃ¡pido: FÃ¡cil de leer para nuevos miembros.
âœ” Arquitectura modular y determinista.
âœ” Alineado con principios ISTQB (separaciÃ³n por capas, auto-verificaciÃ³n).
âœ” Mejor Developer Experience: tipado estricto, errores claros, logs medibles.
âœ” Performance: lazy loading y control de contexto por escenario.

### 3.5 Robustez y manejo de errores
âœ”ï¸ Lo que ya estÃ¡ disponible
- Cada acciÃ³n registra: componente, selector, duraciÃ³n, error.
- El trace JSON es consistente y fÃ¡cil de analizar.
- Contexto aislado por escenario.

âš ï¸ Lo que aÃºn NO estÃ¡ implementado
- Retries inteligentes.
- Estrategias por entorno.
- ClasificaciÃ³n de errores.
- Recovery flows.
- Severidad tÃ©cnica.

ğŸ”œ Lo que habilita la arquitectura

Como toda la lÃ³gica pasa por componentes, es posible implementar:
- Retries centralizados.
- Fallbacks por entorno.
- Manejo de UI volÃ¡til.
- RecuperaciÃ³n de estado.

â¡ï¸ T**odo sin modificar tests.**

## ğŸ§¬ 4. BMS â€” Behavioral Metadata Standard
La pieza que permite trazabilidad completa

Los escenarios Gherkin incluyen metadata estructurada y auditable:
```gherkin
@ID=TC-002
@Title=Valid_login_shows_username
@Module=Authentication
@Component=Login
@AC1=Welcome_message_includes_username
@Data=credentials.valid
@Priority=HIGH
@Risk=LOW
Scenario: Successful login
```

BMS resuelve:
- QuÃ© requisito cubre cada test
- QuÃ© criterios de aceptaciÃ³n se validan.
- QuÃ© datos se usaron
- QuÃ© se ejecutÃ³ realmente y dÃ³nde fallÃ³.

### 4.1 Ejemplo SIMPLIFCADO de salida JSON 
```json
{
  "metadata": {
    "id": "TC-002",
    "title": "Valid_login_shows_username",
    "module": "Authentication",
    "component": "Login",
    "priority": "HIGH",
    "risk": "LOW",
    "acceptanceCriteria": [
      "Welcome_message_includes_username",
      "Login_modal_should_disappear_after_success"
    ],
    "requirements": ["AUTH-101"]
  },
  "execution": {
    "status": "PASSED",
    "durationMs": 2450,
    "steps": [
      { "component": "Navigation", "action": "openHomePage", "status": "PASSED" },
      { "component": "Login", "action": "loginWith", "status": "PASSED" }
    ]
  }
}

```

### 4.2 Governance BMS (cÃ³mo escala en equipos grandes)

**Naming conventions**
- @ID = prefijo + nÃºmero.
- @REQ = ID de requisito (JIRA / ALM).
- MÃ³dulos y componentes definidos por equipo.

**Roles responsables**

- QA Lead / QA Architect definen convenciones.
- Cambios controlados por PR.
- EvoluciÃ³n gradual del estÃ¡ndar.
- EvoluciÃ³n gradual del estÃ¡ndar.

### 4.3 Validador BMS (CI/CD)

Los scripts de validaciÃ³n (/scripts/validate-bms.ts) pueden:
- Bloquear merges si la metadata es incorrecta.
- Comprobar formato y campos obligatorios.
- Detectar duplicados de ID.
- Verificar coherencia de prioridades y riesgos.

### 4.4 RelaciÃ³n con JIRA/ALM

En la versiÃ³n actual:
- @REQ es un string libre que puede mapear a JIRA/Xray/Zephyr.
- ValidaciÃ³n posible vÃ­a ficheros locales o convenciones de equipo.
- Exporters formales (JIRA, Xray, Zephyr) â†’ en desarrollo.

>No se promete una integraciÃ³n que aÃºn no existe, pero la arquitectura ya estÃ¡ preparada para ello.

### ğŸ“Š 5. Reporting â€” Claro para negocio y tÃ©cnico

El reporting parte de:
- Metadata BMS.
- Trace tÃ©cnico.
- Pasos ejecutados.
- DuraciÃ³n.
- Componente / acciÃ³n.
- Resultado y errores.

Esto permite construir:

- Informes funcionales para negocio.
- Informes tÃ©cnicos para QA/Dev.
- Exportadores ALM.
- Dashboards (BAM Radar).
- MÃ©tricas de cobertura y riesgo.

Y todo esto unificado.

## ğŸš¦ 6. Quality Gates (CI/CD)

| Gate               | Regla               | AcciÃ³n                |
| ------------------ | ------------------- | --------------------- |
| **Smoke Gate**     | 100% Critical Flows | ğŸŸ¢ Deploy QA          |
| **Perf Gate**      | p95 < 200ms         | ğŸŸ¡ Warning / ğŸ”´ Block |
| **Stability Gate** | 0% flaky tests      | ğŸ”´ Block release      |

Es posible definir reglas personalizadas de quality gate en el pipeline de CI/CD

## ğŸ”§ 7. Estado actual
| Ãrea                      | Estado           |
| ------------------------- | ---------------- |
| Arquitectura base         | âœ”ï¸ Estable       |
| BMS Standard              | âœ… Completo       |
| Component Model           | âœ”ï¸ Estable       |
| Dual Reporting (JSON)     | âœ”ï¸ Estable       |
| BAM Radar (Dashboard Gobernanza) | âš ï¸ En desarrollo |
| Error Handling Enterprise | âš ï¸ En desarrollo |
| Exporters ALM             | âš ï¸ Roadmap       |
| Self-Healing              | ğŸ”œ PrÃ³xima fase  |

## ğŸ¦• 8. DINO â€” IA Declarativa para potenciar BAM (opcional)

**DINO** (Declarative Intelligence Orchestration) es un proyecto complementario a BAM, aÃºn en fase inicial (PoC).

- ğŸš§ Estado: fase inicial.
- ğŸ§  Foco: modelos locales (Ollama, LM Studio).
- ğŸ’¬ Rol: asistencia, no sustituciÃ³n del QA.
- ğŸ”’ Privacidad: no envÃ­a datos a la nube.

Objetivo: automatizar tareas repetitivas alrededor de BAM:
- GeneraciÃ³n de escenarios.
- GeneraciÃ³n/validaciÃ³n de metadata BMS.
- AnÃ¡lisis de errores.
- Sugerencia de nuevos casos.


## ğŸ“ 9. AlineaciÃ³n con estÃ¡ndares de calidad

BAM no â€œcertificaâ€ cumplimiento, pero su diseÃ±o se alinea con:
| Norma / Marco     | Estado | AlineaciÃ³n                                    |
| ----------------- | ------ | --------------------------------------------- |
| **ISTQB 2023+**   | âœ…      | Capas separadas, autochecking, mantenibilidad |
| **IEEE 29119-3**  | ğŸš§     | Avance hacia IDs/artefactos formales          |
| **ISO/IEC 25010** | âœ…      | Mantenibilidad + analizabilidad               |
| **ISO/IEC 25002** | âœ…      | Base para mÃ©tricas cuantitativas              |

> Estos estados reflejan alineaciÃ³n de diseÃ±o, no una auditorÃ­a oficial ni una certificaciÃ³n formal.

## âš”ï¸ 10. Comparativa de modelos
| Criterio            | BDD clÃ¡sico                | POM tradicional         | **BAM (PoC Beta)**                                 |
| ------------------- | -------------------------- | ----------------------- | -------------------------------------------------- |
| Trazabilidad        | âš™ï¸ Buena (escenarios)      | âŒ Limitada (UI tÃ©cnica) | âœ… Alta (BMS: requisito â†” escenario â†” ejecuciÃ³n)    |
| Mantenibilidad      | âŒ Media/Baja (â€œstep hellâ€) | âœ… Buena (BOs claros)    | âœ… Alta (componentes atÃ³micos + pages declarativas) |
| Velocidad           | âŒ Menor (overhead BDD)     | âœ… Alta                  | âš™ï¸ Media (capa extra + trazas)                     |
| Visibilidad negocio | âœ… Alta                     | âŒ Baja                  | âœ… Alta (Gherkin + metadata BMS)                    |
| Deuda tÃ©cnica       | âŒ Alta                     | âš™ï¸ Media                | âœ… Reducida (selectores en componentes)             |
| Compatibilidad IA   | âœ… Buena                    | âŒ Baja                  | âš™ï¸ Muy buena (estructura clara para DINO)          |
| Escalabilidad       | âš™ï¸ Media                   | âœ… Buena                 | âœ… Alta (component model + BMS + reporting)         |
| Observabilidad      | âŒ Baja                     | âŒ Baja                  | âœ… Mejorada (logger + tracer JSON integrados)       |



ğŸ§© 11. Flujo Completo (Arquitectura)
Gherkin (IntenciÃ³n de negocio)
       â†“
Capa de Componentes y Pages (Modelo de diseÃ±o)
       â†“
BAM Runner â€” Playwright / Axios / k6 (EjecuciÃ³n)
       â†“
BMS JSON v2.1 (Single Source of Truth)
       â†“
Quality Gates (CI/CD)
       â†“
BAM Radar (Reporting unificado para negocio y tÃ©cnico)



## ğŸ§‘â€ğŸ”¬ Contacto
**RubÃ©n LÃ³pez**  - ruben@rulope.com
[GitHub](https://github.com/rubenlopez77) 
[LinkedIn](https://www.linkedin.com/in/ruben-lopez-qa/)
