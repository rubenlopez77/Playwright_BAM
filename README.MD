# ðŸ§ª Behavior Annotation Model (BAM!) â€” Community Edition (PoC)

> ### âš ï¸ Aviso importante â€” Proof of Concept  
> Esta ediciÃ³n es un **PoC evolutivo**, creado para explorar cÃ³mo podrÃ­a estructurarse la gobernanza de calidad en automatizaciÃ³n segÃºn principios **ISTQB**, **IEEE 29119** e **ISO/IEC 25010**.  
> No pretende ser un framework â€œcerradoâ€, sino una **propuesta arquitectÃ³nica** para experimentar con diseÃ±o declarativo, trazabilidad y telemetrÃ­a unificada.

![BAM Community Edition](https://img.shields.io/badge/BAM_Community_Edition-v0.1.5-blueviolet?style=flat-square)

---

> *"La funciÃ³n del QA ya no es 'ver si funciona', sino orquestar la calidad desde la intenciÃ³n del negocio hasta la evidencia tÃ©cnica."*

---

# ðŸŽ¯ 1. PropÃ³sito: Â¿QuÃ© intenta resolver BAM?

BAM nace para explorar cÃ³mo un equipo QA podrÃ­a **gobernar** â€”no solo ejecutarâ€” la automatizaciÃ³n.  
En la prÃ¡ctica, intenta responder a cuatro problemas habituales:

### âŒ 1. Falta de fiabilidad  
Tests frÃ¡giles, flaky tests, reintentos, ruido.  
La suite â€œverdeâ€ en apariencia, pero poco confiable.

### âŒ 2. Evidencia dispersa  
Playwright genera un tipo de reporte, Cucumber otro, k6 otro.  
No existe *una Ãºnica fuente de verdad*.

### âŒ 3. Ausencia de trazabilidad funcional  
Los frameworks tradicionales no responden a:

- QuÃ© requisito cubre cada escenario  
- QuÃ© AC fueron validados  
- QuÃ© datos se usaron  
- QuÃ© mÃ³dulo o componente fallÃ³ realmente  

### âŒ 4. DesconexiÃ³n entre intenciÃ³n de negocio y ejecuciÃ³n tÃ©cnica  
Los steps suelen describir *cÃ³mo* interactuar con la UI, no *quÃ© comportamiento* se estÃ¡ validando.

---

# ðŸŸ£ 2. BAM como modelo: un Single Source of Truth para QA

BAM propone una visiÃ³n simple:

> **Tests funcionales, API y rendimiento pueden compartir un metamodelo comÃºn de evidencias.**

Ese metamodelo es el **BMS (Behavior Metadata Standard)**:  
un JSON canÃ³nico que representa cada ejecuciÃ³n con semÃ¡ntica clara y trazable.

BAM **no es un runner**.  
BAM no reemplaza Playwright ni Cypress.  
BAM **gobierna** la estructura, la intenciÃ³n y la telemetrÃ­a.

---

# ðŸ›ï¸ 3. Arquitectura en 3 capas (alineada con ISTQB)

El diseÃ±o se basa en la separaciÃ³n clÃ¡sica de responsabilidades, pero aplicada con rigor QA:

---

## 3.1 Capa de IntenciÃ³n (Business / Declarativa)

- Escenarios legibles por negocio (pseudo-Gherkin).  
- Metadatos estructurados: `@REQ`, `@AC`, `@Risk`, `@Data`â€¦  
- Define **quÃ©** se quiere validar, no *cÃ³mo*.

---

## 3.2 Capa de Componentes (AbstracciÃ³n TÃ©cnica)

Una capa totalmente encapsulada:

- Componentes UI/API atÃ³micos  
- Pages declarativas  
- Helpers reutilizables  
- Selectores centralizados  

> La intenciÃ³n funcional queda aislada de los detalles tÃ©cnicos.

---

## 3.3 Capa de EjecuciÃ³n (+ TelemetrÃ­a BMS)

La ejecuciÃ³n la realiza el motor elegido (Playwright, Axios, k6â€¦).  
BAM solo aÃ±ade:

- trazabilidad,  
- metadatos,  
- taxonomÃ­a de fallos,  
- estructura comÃºn para todos los tipos de pruebas.  

El resultado es siempre un **BMS JSON** homogÃ©neo.

---

# ðŸŸ¦ 4. Modelo de Componentes â€” Eliminando fragilidad


ðŸŸ¦ Componentes atÃ³micos

Cada interacciÃ³n (click, fill, wait, modal, alertâ€¦) se centraliza en un componente o clase.
```ts
async fill(value: string) {
    return this.world.interactionService.run(
      "Textbox.fill",
      { selector: this.selector, value },
      async () => {
        await this.loc.waitFor({ state: "visible" });
        await this.loc.click();
        await this.loc.fill(value);
        await this.page.waitForLoadState("domcontentloaded");
      }
    );
  }
```
Ventajas:

Un selector â†’ un Ãºnico lugar
ReutilizaciÃ³n masiva
Cambios UI afectan al mÃ­nimo cÃ³digo posible
Control de errores

ðŸŸ¦ Pages declarativas

Una pÃ¡gina solo indica quÃ© componentes contiene.
Sin lÃ³gica tÃ©cnica.
```ts
  async loginWith(set: CredentialSet) {
    await this.loginButton.click();
    await this.modal.waitVisible();
    await this.username.fill(set.username);
    await this.password.fill(set.password);
    await this.submitButton.click();
  }
```

ðŸŸ¦ Steps declarativos y limpios

El Step representa intenciÃ³n funcional:
```ts
When('the user logs in with valid credentials', function () {
  const user = this.getPage(LoginPage);
  user.loginWith(credentials.valid);
});
```
âœ” Arquitectura modular y determinista.
âœ” Alineado con principios ISTQB: separaciÃ³n por capas y auto-verificaciÃ³n
âœ” Developer Experience: tipado estricto, errores claros y logs medibles
âœ” Performance: lazy loading y control de contexto por escenario


---

# ðŸ§¬ 5. BMS â€” Behavioral Metadata Standard

Es la pieza clave del modelo BAM.

### BMS permite responder a:

- QuÃ© requisito se validÃ³  
- QuÃ© AC concretos  
- QuÃ© datos  
- QuÃ© componentes intervinieron  
- QuÃ© fallÃ³ y por quÃ© (taxonomÃ­a)  
- CuÃ¡nto durÃ³  
- QuÃ© evidencias se generaron

### Ejemplo simplificado:

```json
{
  "metadata": {
    "id": "TC-002",
    "requirements": ["AUTH-101"],
    "risk": "LOW",
    "acceptanceCriteria": ["Welcome_message_includes_username"]
  },
  "execution": {
    "status": "PASSED",
    "durationMs": 2450
  }
}
```

### RelaciÃ³n con ALM (JIRA, Xray, Zephyr)

Actualmente:  
- tags libres `@REQ=AUTH-101`  
- validaciÃ³n local de formato  

Roadmap (PoC):  
- exporters,  
- validadores externos,  
- sincronizaciÃ³n ligera.

---

# ðŸ“Š 6. Reporting y BAM Radar

BAM Radar es un experimento de dashboard local (en desarrollo) que consume BMS para:

- detectar flaky tests,  
- encontrar requisitos â€œverde pero dÃ©bilesâ€,  
- visualizar mÃ©tricas temporales,  
- ayudar en Root Cause Analysis.  

> Objetivo: ayudar a un QA Lead a **gobernar la suite**, no solo visualizarla.

---

# ðŸš¦ 7. Quality Gates (PoC)

Ejemplos posibles:

| Gate               | Regla                     |
| ------------------ | ------------------------- |
| Stability Gate     | 0% flaky tests            |
| Perf Gate          | p95 < umbral definido     |
| Risk Gate          | Criticidad 100% cubierta  |

---

# ðŸ”§ 8. Estado actual del PoC

| Ãrea                          | Estado         |
| ----------------------------- | -------------- |
| Arquitectura base             | âœ”ï¸ Estable     |
| BMS Standard                  | âœ”ï¸ Operativo   |
| Component Model               | âœ”ï¸ Estable     |
| Dual Reporting JSON           | âœ”ï¸ Activo      |
| BAM Radar                     | ðŸš§ En desarrollo |
| Error Taxonomy avanzado       | ðŸš§ Parcial     |
| Exporters ALM                 | ðŸš§ Roadmap     |
| Self-Healing                  | ðŸ”œ Futura fase |

---

# ðŸ¦• 9. DINO (Opcional): IA Declarativa

Proyecto complementario (PoC) cuyo objetivo es permitir:

- sugerencia de escenarios,  
- validaciÃ³n de metadata BMS,  
- anÃ¡lisis de patrones de error,  
- explicabilidad tÃ©cnica.

No forma parte del core BAM actual.

---

# ðŸ“ 10. AlineaciÃ³n con estÃ¡ndares de calidad

BAM no â€œcertificaâ€ cumplimiento, pero su diseÃ±o se inspira en los principios de varios marcos reconocidos:

| Norma / Marco     | Estado | AlineaciÃ³n                                                                 |
| ----------------- | ------ | --------------------------------------------------------------------------- |
| **ISTQB 2023+**   | âœ…     | SeparaciÃ³n por capas, mantenibilidad, diseÃ±o declarativo, autochecking      |
| **IEEE 29119-3**  | ðŸš§     | Avance hacia IDs formales, trazabilidad estructurada y artefactos controlados |
| **ISO/IEC 25010** | âœ…     | Mantenibilidad, analizabilidad, estructura modular                          |
| **ISO/IEC 25002** | âœ…     | Base para mÃ©tricas cuantitativas y criterios de evaluaciÃ³n                  |


---

# âš”ï¸ 11. Comparativa de modelos

| Criterio              | BDD clÃ¡sico              | POM tradicional          | **BAM (PoC)**                                           |
| --------------------- | ------------------------ | ------------------------ | -------------------------------------------------------- |
| **Trazabilidad**      | âš™ï¸ Media                 | âŒ Baja                  | âœ… Alta (BMS: requisito â†” escenario â†” ejecuciÃ³n)          |
| **Mantenibilidad**    | âŒ Media/Baja (â€œstep hellâ€) | âš™ï¸ Media/Alta           | âœ… Muy alta (componentes atÃ³micos + pages declarativas)  |
| **Ruido / Fragilidad**| âŒ Alta                  | âš™ï¸ Media                 | ðŸŸ¢ Baja (interacciones centralizadas)                    |
| **Observabilidad**    | âŒ Baja                  | âŒ Baja                  | ðŸŸ¦ Alta (JSON estructurado + taxonomÃ­a de fallos)        |
| **Compatibilidad IA** | âš™ï¸ Media                | âŒ Baja                  | ðŸ¤– Alta (estructura declarativa + metadatos BMS)         |
| **Escalabilidad**     | âš™ï¸ Media                | âš™ï¸ Media/Alta            | ðŸŸ¢ Alta (arquitectura en 3 capas + estandarizaciÃ³n)      |
| **Experiencia QA Lead**| âš™ï¸ Variable             | âš™ï¸ Buen control tÃ©cnico  | â­ Excelente (gobernanza, mÃ©tricas, raÃ­z de fallos clara) |


---

# ðŸ§© 12. Flujo completo (visiÃ³n conceptual)

```
IntenciÃ³n (pseudo-Gherkin)
       â†“
Componentes / Pages
       â†“
EjecuciÃ³n Playwright / Axios / k6
       â†“
BMS JSON (Single Source of Truth)
       â†“
Quality Gates (CI/CD)
       â†“
BAM Radar (Gobernanza)
```

---

# ðŸ§‘â€ðŸ”¬ Contacto

**RubÃ©n LÃ³pez**  
ruben@rulope.com  
GitHub: https://github.com/rubenlopez77  
LinkedIn: https://www.linkedin.com/in/ruben-lopez-qa/
