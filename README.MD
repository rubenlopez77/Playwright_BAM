# üß™ BAM! (Behavior Annotation Model) ‚Äî Community Edition (PoC)

> ### ‚ö†Ô∏è Aviso importante ‚Äî Proof of Concept
> Esta edici√≥n es un **PoC evolutivo**, creado para explorar c√≥mo podr√≠a estructurarse la gobernanza de calidad en automatizaci√≥n seg√∫n principios **ISTQB**, **IEEE 29119** e **ISO/IEC 25010**.
> No pretende ser un framework ‚Äúcerrado‚Äù, sino una **propuesta arquitect√≥nica** para experimentar con dise√±o declarativo, trazabilidad y telemetr√≠a unificada.

![BAM Community Edition](https://img.shields.io/badge/BAM_Community_Edition-v0.1.5-blueviolet?style=flat-square) ![Status](https://img.shields.io/badge/Status-Experimental-orange?style=flat-square) ![License](https://img.shields.io/badge/License-MIT-green?style=flat-square)

---

> *"La funci√≥n del QA ya no es 'ver si funciona', sino orquestar la calidad desde la intenci√≥n del negocio hasta la evidencia t√©cnica."*

---

# üéØ 1. Prop√≥sito: ¬øQu√© intenta resolver BAM?

BAM nace para explorar c√≥mo un equipo QA podr√≠a **gobernar** ‚Äîno solo ejecutar‚Äî la automatizaci√≥n. En la pr√°ctica, ataca cuatro disfunciones habituales en equipos Agile:

### ‚ùå 1. Falta de fiabilidad (Flakiness)
Tests fr√°giles, reintentos infinitos y ruido. La suite est√° "verde", pero nadie conf√≠a en ella para desplegar un viernes.

### ‚ùå 2. Evidencia dispersa (Silos de datos)
Playwright, K6 y Cucumber generan reportes aislados. No existe *una √∫nica fuente de verdad* para responder: "¬øCu√°l es la calidad actual del producto?".

### ‚ùå 3. Ausencia de trazabilidad funcional
Los frameworks tradicionales ejecutan c√≥digo, no requisitos. Es dif√≠cil responder:
- ¬øQu√© requisito cubre este test?
- ¬øQu√© Criterios de Aceptaci√≥n (AC) han sido validados?
- ¬øQu√© m√≥dulo t√©cnico es el m√°s inestable?

### ‚ùå 4. Desconexi√≥n Negocio vs T√©cnica
Los steps suelen describir *c√≥mo* interactuar con la UI ("Click en bot√≥n azul"), no *qu√© comportamiento* se valida ("Usuario se autentica con rol Admin").

---

# üìà 2. Impacto Esperado (KPIs)

El objetivo de BAM no es est√©tico, es econ√≥mico. Busca resultados medibles:

| Objetivo | KPI Estimado |
| :--- | :--- |
| **Reducci√≥n de Ruido** | **30-50%** menos tiempo investigando falsos positivos. |
| **Trazabilidad** | **100%** de trazabilidad (Requisito ‚Üî Test ‚Üî Fallo) en m√≥dulos cr√≠ticos. |
| **An√°lisis de Fallos (RCA)** | Reducci√≥n del **40%** en el tiempo medio de diagn√≥stico gracias a la taxonom√≠a unificada. |

---

# üü£ 3. BAM como modelo: Single Source of Truth

BAM propone una visi√≥n simple:

> **Tests funcionales, API y rendimiento pueden compartir un metamodelo com√∫n de evidencias.**

Ese metamodelo es el **BMS (Behavior Metadata Standard)**: un JSON can√≥nico que representa cada ejecuci√≥n con sem√°ntica clara.

* **BAM no es un runner.**
* **BAM no reemplaza Playwright ni Cypress.**
* **BAM gobierna** la estructura, la intenci√≥n y la telemetr√≠a.

---

# üèõÔ∏è 4. Arquitectura en 3 capas (Alineada con ISTQB)

El dise√±o aplica una separaci√≥n estricta de responsabilidades para garantizar mantenibilidad a largo plazo:

## 4.1 Capa de Intenci√≥n (Business / Declarativa)
Define **QU√â** se quiere validar.
- Escenarios legibles por negocio (pseudo-Gherkin).
- Metadatos estructurados: `@REQ`, `@AC`, `@Risk`, `@Data`.

## 4.2 Capa de Componentes (Abstracci√≥n T√©cnica)
Define **C√ìMO** se interact√∫a.
- Componentes UI/API at√≥micos y aislados.
- Pages declarativas sin l√≥gica de control.
- Selectores centralizados (Single Point of Maintenance).

## 4.3 Capa de Ejecuci√≥n (+ Telemetr√≠a BMS)
El motor (Playwright, Axios, k6) ejecuta la acci√≥n. BAM intercepta la ejecuci√≥n para inyectar:
- Trazabilidad y Metadatos.
- Taxonom√≠a de fallos autom√°tica.
- Generaci√≥n del **BMS JSON**.

---

# üü¶ 5. Eliminando fragilidad

### üü¶ Componentes At√≥micos (Interaction Wrapper)
Cada interacci√≥n (click, fill, wait) se centraliza para inyectar estabilidad y telemetr√≠a autom√°tica.

```typescript
async fill(value: string) {
    // El 'InteractionService' maneja la espera, el reintento y el log de negocio
    return this.world.interactionService.run(
      "Textbox.fill",
      { selector: this.selector, value },
      async () => {
        await this.loc.waitFor({ state: "visible" });
        await this.loc.click();
        await this.loc.fill(value);
      }
    );
}

```

## üü¶ Pages declarativas

Una p√°gina solo indica qu√© componentes contiene.
Sin l√≥gica t√©cnica.

```ts
loginWith(set: CredentialSet) {
  this.loginButton.click();
  this.modal.waitVisible();
  this.username.fill(set.username);
  this.password.fill(set.password);
  this.submitButton.click();
}
```

### üü¶ Steps declarativos y limpios

El Step representa intenci√≥n funcional:
``` ts
When('the user logs in with valid credentials', function () {
  const user = this.getPage(LoginPage);
  user.loginWith(credentials.valid);
});
```

‚úî Arquitectura modular y determinista.

‚úî Alineado con principios ISTQB: separaci√≥n por capas y auto-verificaci√≥n 

‚úî Developer Experience: tipado estricto, errores claros y logs medibles  

‚úî Performance: lazy loading y control de contexto por escenario

### üü¶ Onboarding inmediato

Nuevos miembros solo deben conocer:

- Componentes
- P√°ginas
- Steps declarativos

No necesitan entender l√≥gica interna.

# üß¨ 5. BMS ‚Äî Behavioral Metadata Standard

Es la pieza clave del modelo BAM.
BMS permite responder a:

- Qu√© requisito se valid√≥
- Qu√© AC concretos
- Qu√© datos
- Qu√© componentes intervinieron
-  Qu√© fall√≥ y por qu√© (taxonom√≠a)
-  Cu√°nto dur√≥
-  Qu√© evidencias se generaron

Ejemplo simplificado:

```json
{
  "scenario": {
    "id": "TC-002",
    "name": "Successful login",
    "feature": "Login",
    "tags": [
      "@PRIORITY=HIGH",
      "@RISK=LOW",
      "@AC1=Welcome_message_includes_username"
    ]
  },
  "execution": {
    "durationMs": 2754,
    "timeline": [
      {
        "gherkin": "the user logs in with valid credentials",
        "status": "PASSED",
        "durationMs": 750,
        "actions": [
          {
            "name": "Button.click",
            "selector": { "value": "#login2" },
            "timing": { "actionMs": 53 }
          },
          // ... (actions continue)
        ]
      },
      {
        "gherkin": "the user should see his name in the top bar",
        "status": "PASSED",
        "actions": [
          {
            "name": "Wait.text(\"admin\")",
            "selector": { "value": "#nameofuser" },
            "status": "PASSED"
          }
        ]
      }
    ]
  }
}
```

# ‚úîÔ∏è 6. BAM Garantiza la Calidad en la Escritura de Pruebas
El Modelo BAM establece un marco unificado para dise√±ar, ejecutar y gobernar pruebas con trazabilidad total, alta mantenibilidad y m√©tricas operativas alineadas con est√°ndares ISTQB. 
- Un escenario expresa una √∫nica intenci√≥n de negocio.
El t√≠tulo debe describir claramente el resultado esperado, no la secuencia de acciones.
- Steps basados en comportamiento, no en implementaci√≥n
Gracias a su arquitectura por capas (Steps ‚Üí Helpers ‚Üí Components), BAM a√≠sla la l√≥gica t√©cnica fuera del escenario.
- Lenguaje preciso y conciso, sin ambig√ºedades.
Cada frase debe ser verificable y comprensible por cualquier lector, incluso no t√©cnico.
- Consistencia editorial en todo el proyecto.
Misma forma de nombrar, mismo estilo, mismas reglas. Las pruebas deben parecer escritas por una √∫nica persona.

Tanto el plugin ESLint como BAM Radar act√∫an como mecanismos de control para asegurar la calidad del modelo BAM

# üöÄ 7. Estrategia de Adopci√≥n 

BAM est√° dise√±ado para la realidad de los equipos, no para laboratorios. Permite una adopci√≥n progresiva:

- Fase 1 (Telemetr√≠a): Ingesta de resultados actuales (JUnit/Cucumber) para generar BMS b√°sico sin reescribir tests.

- Fase 2 (Dise√±o): Migraci√≥n de m√≥dulos cr√≠ticos a la arquitectura de 3 capas y componentes at√≥micos.

- Fase 3 (Gobernanza): Despliegue de Quality Gates basados en datos (e.g., "Bloquear release si Risk Coverage < 80%")


# ü§ñ 8. AI-Ready por Dise√±o

La Inteligencia Artificial necesita contexto estructurado, no logs de texto plano. Al formalizar el dise√±o (Capas) y la ejecuci√≥n (BMS), BAM proporciona a la IA los datos limpios que necesita para:

- Sugerir nuevos escenarios basados en riesgos no cubiertos.
- Detectar patrones de flakiness invisibles al ojo humano.
- Auto-reparaci√≥n de selectores (Self-Healing) con contexto sem√°ntico
- Propuestas de mejoras en assertions o dise√±o
- Evoluciona la estabilidad

# üìä 9. Reporting: BAM Radar


BAM Radar es un dashboard de an√°lisis desplegable localmente que consume BMS y ayuda al QA en el d√≠a a d√≠a. Permite:
- Detectar y priorizar flaky tests
- Identificar requisitos ‚Äúverde pero poco cubiertos"
- Apoyar el Root Cause Analysis
- Decidir d√≥nde invertir esfuerzo de refactorizaci√≥n en cada sprint
- Visualizar m√©tricas temporales,  


> Objetivo: ayudar a un QA Lead a **gobernar la suite**, no solo visualizarla.

---
# üö¶ 10. Quality Gates (PoC)

Ejemplos posibles:

| Gate               | Regla                     |
| ------------------ | ------------------------- |
| Stability Gate     | 0% flaky tests            |
| Perf Gate          | p95 < umbral definido     |
| Risk Gate          | Criticidad 100% cubierta  |

---

# üîß 11. Estado actual del PoC

| √Årea                          | Estado         |
| ----------------------------- | -------------- |
| Arquitectura base             | ‚úîÔ∏è Estable     |
| BMS Standard                  | ‚úîÔ∏è Operativo   |
| Component Model               | ‚úîÔ∏è Estable     |
| Dual Reporting JSON           | ‚úîÔ∏è Activo      |
| BAM Radar                     | üöß En desarrollo |
| Error Taxonomy avanzado       | üöß Parcial     |
| Exporters ALM                 | üöß Roadmap     |
| Self-Healing                  | üîú Futura fase |




# ‚öîÔ∏è 12. Comparativa de modelos

| Criterio              | BDD cl√°sico              | POM tradicional          | **BAM (PoC)**                                           |
| --------------------- | ------------------------ | ------------------------ | -------------------------------------------------------- |
| **Trazabilidad**      | ‚öôÔ∏è Media                 | ‚ùå Baja                  | ‚úÖ Alta (BMS: requisito ‚Üî escenario ‚Üî ejecuci√≥n)          |
| **Mantenibilidad**    | ‚ùå Media/Baja (‚Äústep hell‚Äù) | ‚öôÔ∏è Media/Alta           | ‚úÖ Muy alta (componentes at√≥micos + pages declarativas)  |
| **Ruido / Fragilidad**| ‚ùå Alta                  | ‚öôÔ∏è Media                 | üü¢ Baja (interacciones centralizadas)                    |
| **Observabilidad**    | ‚ùå Baja                  | ‚ùå Baja                  | üü¶ Alta (JSON estructurado + taxonom√≠a de fallos)        |
| **Compatibilidad IA** | ‚öôÔ∏è Media                | ‚ùå Baja                  | ü§ñ Alta (estructura declarativa + metadatos BMS)         |
| **Escalabilidad**     | ‚öôÔ∏è Media                | ‚öôÔ∏è Media/Alta            | üü¢ Alta (arquitectura en 3 capas + estandarizaci√≥n)      |
| **Experiencia QA Lead**| ‚öôÔ∏è Variable             | ‚öôÔ∏è Buen control t√©cnico  | ‚≠ê Excelente (gobernanza, m√©tricas, ra√≠z de fallos clara) |

# Autor 
He dise√±ado e implementado BAM a partir de mi experiencia creando frameworks de 
automatizaci√≥n y acompa√±ando el trabajo diario de QA: estabilizando suites UI/API,  
entendiendo por qu√© fallan las pruebas y d√≥nde se genera deuda de QA, priorizando qu√© refactorizar en cada sprint, y explorando c√≥mo estructurar los datos de pruebas para que una IA pueda trabajar con ellos sin perder gobernanza.

**Rub√©n L√≥pez**  
ruben@rulope.com  
GitHub: https://github.com/rubenlopez77  
LinkedIn: https://www.linkedin.com/in/ruben-lopez-qa/
